
commutative propiety of idempotent ciphers : S1 x S2 = S2 x S1

**AES** 

3 -> linear operators 1 -> non linear

logher keys -> higher security -> lower performance

works on 2^8 galois field -> all possible bytes -> operation between strings of lenght 8 / polynomials

`11010011` -> $x^7 + x^6 + x^4 + x^1 + x^0$ 

operations : 
+ sum -> bit-wise xor 
+ mult 

mult > result should be vector of $l = 8$  -> standsard mult + reduction

ex : $x^{12}+x^6+x^5 + x^3 + x^2 + x^1$
divide by *irreducible polynomial*  =  $x^8 + x^4 + x^3+ x^1 + 1$ -> just do xor between binary rapresentation of these until we have less than 8th power

9 4 8 3 5 0
1100111001
1000110110

0100001111
0100011011

0000010100

optimization
rewrite as binary strings > check last bit of b -> if 1 remove from b and add 0 to the right of a + change p take the old value of p and xor with a -> new p 
if 0 remove 0 from b and add 0 to a -> dont tuch p -> the last value of p -> the result of multiplication

```python
def AESmult(a, b):
    p = 0                       # p is 0 at the beginning
    for i in range(0,8):        # for the 8 bits of a and b do:
        if b & 1 != 0:          # the least significant bit of b is set
            p = p ^ a           # sum a to p (xor)
        b >>= 1                 # shifts b to the right
        hbit = (a & 0x80) != 0  # true if the most 8th significant bit of a is set -> larger than 8th
        a <<= 1                 # shifts a to the left
        if hbit:                # if the most significant bit of a was set
            a = a ^ 0x11b       # sum 100011011 to a (xor), this always returns
                                # a 8-bit number
    return p
```

if at some point a too big ->devide by reducible polynomial simply xor a with reducible poly

110010000 10
as soon as it becomes larger do division
110010000 XOR
100011011 =
010001011
add 0 after performing xor
0100010110 1

b times -> at max 2b if division every time 

*AES schema*

works with 4x4 matrix of bytes 
how many rounds of AES -> depends of size of the key 10 for 128 but keys , 12 - 192 , 14 - 256

4 operations :
1. bitwise xor
2. non linear substitution -> with table
3. shift rows matrix
4. multiply matrix

xor matrix a  with matrix containing the key 

S-box -> substitution -> depending on value in the matrix replace with one in a fixed matrix 
0x25 -> look at fix matrix in row 2 col 5 -> write in that value

Shiftrow -> first row not tuched , by 1 the 2nd , by 2 the third , by 3 the last one

mixcolumns mult with a special matrix for all the cols

