vigenere ciphers 

statistical analysis attacks on polyalphabetic ciphers

long text -> get the frequency of each letters 
language of the plaintext match frequency in the language with the ones detected 

similar prob may be mixed

we need lots of data

polyalphabetic ciphers -> letters not mapped always in the same letter 

key -> word of lenght m (longer better) one after another > same as in the sobstitution cipher

decription -> $-$ 

```
STWXXWJ -
FLUTEFL = 
13 8 2 4 19 17 24
NICETRY
```

Formalization : 

$E_{k_1, \dots, k_m}(x_1,\dots, x_m) = (x_1 + k_1, \dots, x_m + k_m) \mod{26}$
$D_{k_1, \dots, k_m}(y_1,\dots, y_m) = (y_1 - k_1, \dots, y_m - k_m) \mod{26}$

$P=C=K=Z^m_{26}$ 
$Z_{26}^m$ strings repeated m times

*key* guessing = $26^m$ (dictionary test ??? ) if $m$ small ez

cryptanalysis for polyalpahbetic cyphers
Friedman method : 
1. recover $m$ 
2. recover the full key

with m lenght create subcyphers corresponding to each shift on the key -> like shift cyphers 

guessing m 

coincidence index :
$f_i$ = frequency of the $i$-th letter $n$ = lenght of the text
than the prob to see $i$-th letter $p_i = \frac{f_i}{n}$

if i remove that letter the prob  to refind the same letter : 

$$\frac{\sum_{i=1}^{26} f_i(f_i -1)}{n(n-1)} \approx \sum_{i=1}^{26} p_i^2$$

every language a specific index of coincedence 

example :

the index of coincidence
$c(3*2)$ 
$21(20 -1)$ 

for the full text :
$$
\frac{c(3*2)+ d(2*1)+ e(4*3)+ f(1*0)+ h(1*0)+ i(3*2)+ n(3*2)+ o(2*1)+
t(1*0)+ x(1*0) }{21 * 20}$$
only once = not interesting 

in a random sequence : small index of coinceicidence -> letter will likely appear only once 

cypher : bmqvszfpjtcsswgwvjlio

if letter only once 0.038 -> in a text with *uniform probability* 
average text in english -> ic 0.065

polyalphabetic cypther IC $\approx$ 0.038 similiar tu *uniform disitribution*
monoalphabetic $IC \approx 0.065$ -> similar to the IC of the original language


```python
m = 1
LIMIT = 0.06 # IC of the language
found = False
while(not found):
	# analyze cy with jumps of m
	# compute IC if < than limit than not written in english
	# IC > limit -> substring in english
	sub = subciphers()
	found = True
	for i in range(0,m):
		if Ic(sub[i]) < LIMIT:
			found = False
			m += 1
			break
print m

```