map X into a smaller message with cryptographic hash function 
sha3 

send pair of message + sign (dec of hash of message ) -> apply encryption and check if the hash fo the message is equal to the output of encrytpion

1 preimage resistant -> we cant go back to any original value since there can be collision 

xor a block with all 0 -> the block itself > xor not ok for hash

2 second preimage resistance -> we dont want that attakcer can comute x2 suche that h(x1) = h(x2) *given* x1 should be computationally infeasable 

in this way we could forge a new sign that is valid but for a different message 

3 collision resistant : infisible to *generate* two x1  x2 such that h(x1) = h(x2) -> this includes prop 2 and 1 ( not the contrary )
as long as the size of the plaintext must be at least 2 time the size of the result 

if the funcion is not preimage resistant than also not collision resistant 

build algo that takes the digest and goes back ( since we hyptoezize that its not preimage resistance ) > we can go back to 2 different if it has collision -> if we go back to different value -> 2 values with same digest-> not collision resistant 

if its 2x the size 1/2 i will be unlucky to find 2 different values with 1/2 prob 

xor -> we just neet to get permutation we will have same hash -> or the contrary 

md5 collision attack

