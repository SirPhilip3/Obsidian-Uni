challenge response protocol

symmetric auth > for each auth different auth string to avoid reaply attacks 
+ add seq number 
+ add timestamp
+ add nonce -> first agree on nonce and than use it to "sign" the comms -> discarded after one communication 

seq number needs to be accepted not only if prev+1 since some packets maybe lost 

guess the decrypted number -> 1/2^n -> but we only need to find a smaller number 
we send a crypto hash of seq number + enc of seq number -> hash its a proof that the one sneding the message know the content of the message 

now attacker needs to also know the hash > crypto secure 1/2^128 if hash generates stings of 128 bits 

reflection attacks : 
attacker send back to the sender the message -> same timestamp of A > message will be accepted since tA - tA = 0 < w -> smaller than a window

attack works since schema is symmetric

9798-2 

one pass unilateral authentication 
encryption timestamp + B -> who is the intended riciever -> if it comes back to A he's not the intended reciever

two-pass unilateral authentication with nonces -> first pass send the nonce than the encrypted 

two pass mutual -> they send both between A and B with timestamp 

three pass mutual with nonce 
B -> A : Nb
A -> B : Ek(NA,NB,B)
B -> A : Ek(NB,NA)

---

key exchanges with symmetric key

session key -> new shared key used only for that conversation 



