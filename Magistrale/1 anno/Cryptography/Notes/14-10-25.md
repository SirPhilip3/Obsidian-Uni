stream chiphers

block chipher -> for each message block encrypth with same key
same key is the problem

changing key every time, initially the shared key

stream chiphers -> uses a stream of keys based on a first key given 

z depends on the initial key -> than mechanical way of generating the next keys 

if the reciever can decrypt at lest the first one than we can use the blocks to generate new keys 

periodic stream -> blocks of z that repeats over time -> the vigene chipher is an instance of this

syncronous -> the next z_i depends on k and not on the previous input
-> this stream can be precomputed

asyncronous cipher
autokey cipher -> $z_i = f(k,x_1,\dots,x_n)$  -> $E = (x_i + z_i) \mod{26}$ , $D = (y_i - z_i)\mod{26}$

assume that $z_1 = k$ , $z_2 = x_2 - 1$ , $\dots$ 

example

networksecurity with k=5

networksecurity -> 13 4 19 22 14 17 10 18 4 2 20 17 8 19 24

13 + 5 mod 26 -> 18
4 + 13 mod 26 -> 17
...

dec -> 18 - 5 mod 26 -> 13 , 17 - 13 mod 26 -> 4 , ...

just brouteforce the first one ?????

---
perfect cipher 

exist but unpractical

assuming that the attacker only sees ciphertexts , the attacker can't access any information -> only option is to guess 

$P_{p(x)}$ prob of a plaintext x to occur
$P_{K(k)}$ prob of a certain key is used in the encryption 

$p_{c(y)}$ -> probability of ciphertext y appearing 
$$p_{c(y)} = \sum_{k \in K , \exists x | E_k(x)=y} p_K(k)p_p(D_k(y))$$
sum off the probability of all the key multiplied by the probability of the corresponding plaintext 

conditional probability of a given ciphertext
if you see x than what is prob that you see y as ciphertext
p_c(3) p_c(3|a) p_c(3|b)

