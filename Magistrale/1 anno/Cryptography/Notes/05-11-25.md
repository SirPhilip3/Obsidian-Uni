Rsa cipher [[RSA]]

uses the euler function -> number of numbers less than n that are coprime with n 

example 
1 2 3 4
remove common divisor with n 
phi(4) -> (1,3) -> 2 
phi(7) -> since prime -> n-1

n -> mult of different prime numbers -> phi(n) = phi(p1)phi(p2) = (p1-1)(p2-1)

phi(15)=phi(3)phi(5) = 2 * 4 = 8 

proof for two primes : 
phi(p)phi(q) n = pq

we cant take any number kp k\in R until (q-1)p
we also cant take any numbers k1q up to (p-1)q

we than remove q-1 and p-1 numbers 
n-1 = pq-1 -(q-1) - (p-1) = pq-q-p-1 = (p-1)(q-1) remaining numbers 

--
chose an n of 2 big prime numbers p , q 

chose another number a that is prime with phi(n) smaller than phi(n)
b -> such that a * b \mod phi(n) = 1

public key = b n , private key > a , n(also in pubk) 
E(x) = x^b \mod **n** 
if we dont use the mod -> just compute the b root of y  

D(y) = y^a \mod **n** 

from n imp to compute p and q 

comp feasable for the generation of the key pair 

implementation > good impl -> n = 1024bits -> 2^1024 for the exponentiation -> we need a polynomial implementation 

molt of 2 number of k bits k^2 ops -> exponentiation $2^k * k^2$ 