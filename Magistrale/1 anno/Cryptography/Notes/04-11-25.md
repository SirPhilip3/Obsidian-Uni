public key cipher 

symmetric key > for each reciever and sender one shared key 

n(n-1) /2 keys in a complete system O(n^2) keys 

each user 1 public 1 private key (asymmetric-key cipher)

encrypt a message with the public key of the dest -> dec with private key 

**Definition**

$PK_A$ -> public key of A
$SK_A$ -> secret key of A 
$E_{PK_A}(M) = e$ with symmetric cipher ?? -> $D_{SK_A}(e) = M$

$(P,C,K_S \times K_P,E,D)$ 
where $E: K_P \times P \to C$ , $D:K_S \times C \to P$ 

>[!note] for the user  
>Comput easy to decrypt , encrypt and compute the key pairs

knowing  the public key an attaccher [[Computationally Impossible]] to compute decrytpion or the private key 

no authentication (digital signature)

example cipher 

one way trapdoor functions > 
+ one way $\iff$ -> f(x) -> y ez x = f^-1(y) invertible but computationally infeasable if we dont have some more information (trapdoor)
+ trapdoor -> injectible , invertible infeasable unless we know a trapdoor $S(k)$ $y=f_k(x)$ is easy , $x = f_k^{-1}(y)$ easy if we know $k$

**merkle hellman knapsack** 

besed on np-c problem *subset sum* find a subset of number from subset $S$ such that they sum to a target T 

1 -> if we take it , 0 otherwise = vector $x$
$$
\sum_{i=1}^n x_i s_i = T
$$
easy to compute given $x$ and $s$ 
having the result -> solution of the subset problem (np-c) -> in order to make it easy -> not npc if sequence of number are *superincreasing* -> each s_i strictly bigger than the sum of the previous ones  

start from the biggest number > if it fits on the target take it and T minus this stop at 0
its always good to take a number since all the previous will not sum to that 
if there is *no solution* > T not 0 at the end 

poly time algo 

public and private key (related to superincreasing function)

private key -> start from n superincreasing numbers
1. p prime bigger than the sum of all the number in the superincerasing 
2. get a random between 1 and p 
3. transform the sequence where $s_i = a s_i \mod p$ (**public key**)

*trapdoor* = p , a and the original sequence 

*secret key* = original sequence 

encryption -> multiply the vector of the message (binary message -> text -> ascii -> binary) by the public key -> the cyphertext -> a number 

decryption -> the subset sum problem solved with as target a number -> since the public is not superincreasing if the attacker doesn know the trapdoor the problem is npc 

target = $a^{-1}\cdot y\mod{p}$ solving the problem with the superincreasing list 

>[!example] 
>slides

calc ok during the midterm

