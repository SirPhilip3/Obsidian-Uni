---
~
---
composition with formal def 

vigene + vigene = vigene 

m blocks -> m different keys 

composition E2(E1) -> new keys > composition of the two 
D1(D2)

simply sobstitute the dec and enc function -> for vigene key same lenght 
$E_{k'}(E_{K}) =E_{k'}(x+k \mod 26) = x+ k + k' \mod{26}$ new key as vigene $k+k'$

in practice for rsa we start with a fixed B and than compute a -> symmetric

$7b\mod{20} = 1$ 7 and 20 eulers th -> if 2 coprime than $7^{\phi(20)}\mod{20} = 1$ 
$\phi(20) = 1,3,7,9,11,13,17,19 =8$
$7^{8} \mod{20} = 1$ -> replace b with what is missing to get to 7^8 -> 7\^7

we compute than 7^7 \mod 20 = 3 

9 -> 20 coprime -> 9^7 \mod 20 = 9 

square and multiply not in the test 
3^13 -> 13 as binary -> start from most significant if find 1 square base nad mult by the base 0 just square 

---
generating rsa exponents -> two random numbers have prob to be coprime 0.6 -> to pick a random can be done 2-3 times 

b is fixed to 2^16 +1 prime small number to improve enc performance -> private key is inverse modulos phi of n which will be different all the time 

n should chosen where it phi shouldnt become a multiple of b

if an attacker knows phi(n) > attack successfull  -> we can easily compute a as the inverse 

we would need to be able to factor n in pq 

in order to not be factorizable n should be at least 3072 bits 

if attacker knows n but not pq -> but attacker knows phi(n)

we can just solve a system in 2 eq as 
n = pq
phi(n) = (p-1)(q-1) 

generating 2 prime numbers -> if we are looking for small primes ok otherwise no

if we give n list of all the prime before n 

list of all the number up to n -> at every step we remove 