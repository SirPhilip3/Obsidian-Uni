swap if b larger than a 

---

OFB mode

generate a stream of keys mixed with input for randomness 

given k and an initial iv -> use encryption to generate z_1 from those and than xor with input to get y_1 

than reusee at next block z_1 instead of IV (IV needs to be random)

we can precompute the key stream 

decription simply in the xor we swap the data flow 

the key stream -> uses same as cbc 

weekness -> when i encrypt 2 messages with the same IV -> we generate the same key stream -> so if a plaintext is same in some block the ciphertext in that block will be same

IV can be shared in clear

integrity -> if mimt -> the change of 1 block will only propagate to the next block 

CTR mode variant of ofb 

we start with IV(nonce) + counter (increases by for each block encrypted)

CFB -> cipher feedback mode

how we generate x_i -> start with IV very long -> at a genric point we add a y_i to the left and shifts iv to the right by y_i -> each step add the y next 

if IV is big we may put it in the next one 

worse perfomance no parallelism

---

other ciphers

+ DES
+ 3-DES
+ IDEA 
+ blowfish , twofish
+ rc2. rc5 , rc6

**des**

key-lenght = 64 -> 8 used for error correction , 56 real key 

16 rounds -> 
	initial permutation
	bits of key in 2 -> 32 to feistel box , other 32 to xor with the output of the feistel scheme 
	for 16 times each you switch bits to the box to the xor and contrary 
	final permutation

feistel schema :
1. 32 bits in input -> expansion function to 48 bits xor with 48 bits from the key 
2. result passed to sboxes -> 8 sboxes each 6 bits -> compresses the bits to 4
3. output gets permutated 

provides confusion and diffusion principle -> input -> output a compleatly random string 

confusion -> operations are sc output is full different from the input
diffusion -> if cahnge 1 bit in the input result will be fully differente from the unchanged input 

3des -> 3 iteration of des each time with different key

meet in the middle attack -> 2des -> 2 keys of 56 bits 

does iteration make sense (des needs to be non-idempotent) 
prob that we get in the same cipher when $S \times S = S$

des input = 64 bits 
all the possible blocks = $2^{64}$ 
for each a different key  we get a permutation of the input 

how many possible permutaition can we generate $2^{64}!$ -> but we have at most $2^{56}$ keys 

mapping key to all permutation we will have that one key to more plaintexts

starting from a set to the same set is $2^{56}/2^{64}!$ -> this is negligable -> des is non-idempotent

meet in the middle attack -> doubledes

we have pairs of plain and cipher
starts from Y applies dec using all the possible 56 key bits , set of possible decription

now all possible k_1 with a plaintext that he knows to encryption -> he will check with the generated dec the one that corresponds maybe the 2 keys are correct

he can use the found key on other known pairs 
2^57 steps 

prob that he found false keys : size of all possible keys / size of all the possible ciphertext = 2^48 -> number of false keys 

just checking with other pairs 

with 3 the prob goes down significatly 

in 3des we cant do this because we need to check the encryption with at least 2 keys -> we would need to generate all the possible pairs $2^{112}$ 

