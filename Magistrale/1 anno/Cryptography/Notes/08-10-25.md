knowledge based attacks: 

+ known plaintext 
+ chosen plaintext
+ chosen ciphertext

known plaintext -> pairs of ciphertext and corresponding plaintext

chosen-plaintext -> attacker ask oracle the encryption of some plaintext

chosen-ciphertext -> attacker can ask an oracle the decription of some ciphertext

---
known plaintext

matrix m * m  -> we need at least m pairs 
for m=2 2 pairs

$Y = XK\mod{26}$ where Y and X are the matrices of the known ciphertext and plaintext

$$Y = \begin{pmatrix}
19 & 4\\
24 & 11
\end{pmatrix}$$
$$X = \begin{pmatrix}
5 & 9\\
2 & 5
\end{pmatrix}$$
if X is *invertible* we can go back to it 
$$X^{-1} Y \mod{26} = X^{-1} X K \mod{26}$$
$X^{-1} X = 1$ 
$$K = X^{-1} Y \mod{26}$$works bc we only use linear opertions in the cipher

---
todo
---
standard euclidian algo : 
greatest common denominator 15 10 -> 5
```python
def Euclid(c,d):
	while d != 0:
		tmp = c % d
		c = d
		d = tmp
	return c 
```

15 = 10 * 1  + 5 
tmp = 5 
c = 10 
d = 5

10 = 5 * 2 + 0
tmp = 0
c = 5 -> result
d = 0 -> end  

extended euclidian algo -> computes the inverse of a numbers
$q = c / d$ -> integer division
$tmp = c - q * d$ -> reminder

inverse(c, value of the modulus)

```python
def extEuclidina(c,d):
	d0 = d
	e = 1
	f = 0
	while d != 0:
		#standard gcd
		q = c / d
		tmp = c - q * d
		c = d
		d = tmp 
		
		tmp = e - q * f
		e = f
		f = tmp
	if c == 1 :
		return e % d0	
```

 