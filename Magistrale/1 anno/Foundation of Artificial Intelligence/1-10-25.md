Search problem (symbolic ai)  
reduce the problem to search within a graph 

+ states
+ action 
+ goal test -> how to recognize that a state is the final solution

res stategy seq of action from initial state to one that satisfies the goal test 

**Blind Search** -> we know only the first neighbouring states and the alphabet (uninformed)

*states* : all relevant aspects of the problem 
*actions* : what can be performed on the states ->  what takes you from state to state 
*goal test* : accepting state

graph can be continuosly generated on the fly -> the graph can be not finite

the full tree can not be maintained in memory fully -> just use the last node and the possible action that can be taken from there 

we can always turn graph into a tree by duplicating nodes that have multiple path to it from the source node in order to make unique paths 

downwards tree -> if we have cycle we can see multiple Starting node -> infinite path  

example game of 8 tile moving game (ex ignore backtracking)

*crosswords* : 2 sol :
+ using word dictionary as possible moves
+ exploring the full space of possible works (even illegal)

how do we select the best type of embedding :
+ completeness -> will we find the solution
+ optimality -> is the solution found the best one
+ temp complexity 
+ spatial complexity

```python
search (G , source , is_goal ) :
	L=[ source ] # list of visited but
	# not expanded nodes
	while L :
		n = extract_from( L ) # expand node n
		# the policy with which we get the node changes the algo
		if is_goal( n ) : # goal node found
			return path( source , n )
		# goal not found , visit adjacent nodes
		children = G.adjacent( n )
		insert_into(L , children) # changes the algo
return FAIL # goal not present in G 
```

*visited* and *expanded*

+ **BFS** (*breadth-first search*) :

level search every elm of the next level will be insert in L before expanding it 

>[!important] 
>the branching factor is finite 

+ *complete* > eventually it will visit a level L so that it contains a goal state 
+ *optimal* returns always the first goal level -> although if at the same level more than 1 we cant know which will be returned ?? 

**complexity** :
+ constant branching factor : $b$ 
+ the first goal is at level $d$ -> will never expand beyond $d$ and never visit beyond $d+1$ 

number of nodes at level $d$ = $b^d$ 

>[!warning] 
>problem with no solution -> infinite search 

**Temporal complexity** : 

nodes to be *examined* to reach $d$ : $\frac{b^d-1}{b-1}$

average nodes to be explored : $\frac{1+b^d}{2}$

total complexity : 
$$\frac{b^d-1}{b-1} + \frac{1+b^d}{2} = \frac{b^{d+1} + b^d + b -3}{2(b-1)} = O(b^d)$$
amount of work at the last layer > than all the other one
exponential complexity -> dom by the work at the last layer

**Spacial complexity**

$O(b^d)$ -> it explores , put on the list all the nodes of the next layer

+ **DFS**

*LIFO* container policy
+ not complete -> if it goes in an infinite path (loop)
+ no optimal -> it depends on the starting consition which goal get's reached first (start in the right find a goal at level 3, but on the left goal at level 1)

**Temporal complexity**
assumption
+ tree at depth $d$
+ 1 goal at depth $d$  -> in reality we don't know -> tecnically unbuounded
+ constant branching factor $b$ 

best case -> all on the left -> only needs to explore $d+1$ nodes
worst case all on the righe :
$$\frac{b^{d+1} -1}{b-1}$$
average : 
$$\frac{b^{d+1} + bd + b -d -2}{2(b-1)}$$
searching half the tree in average (binary search tree)
for every subtree we search half of it

**Spacial complexity** 

best -> the full run down + the last layer 
$$d(b-1)+1$$

+ **Iterative **