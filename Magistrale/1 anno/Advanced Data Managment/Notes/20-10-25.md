cassandra : high ingestion rate as a goal , only api -> access by column name 

not necessary ultra fast access to the data 
1. keeping data in memory very fast but at some point we need to write to the disk

mesure to confront performance between implementation -> educated guess -> count the number of pages that we need to access in the disk -> hypotesis -> no cache 

disk ->
+ append at end of file 
	+ cost = get the last page of a file write it and than write it back to disk
	+ fastest way to write data 
	+ disadvantage : no efficent way of seasrching data by its content

when a memorytable is full is sort it's content and than write it to disk
1 memtable for each  column family

works of if the data is immutable -> ex when use clicked on something
if it changes we need to say that the past event is invalid -> costly to change it we need maybe to change the ordering -> we just say that the previos data is no longer valid 

we have versioning -> sideeffect of other design choices 

changing -> new value that says its the most recent version of the data (timestamps)

deletion using logical deletion -> just flag the record as deleted remains there until compaction > generally more common on disk based infrastructure

we can't add a flag since data is immutable we can't change it -> we need to declered it with adding a new record with same key -> *tombstones* 

still there but invisible to the user , we can do this for a column or a column family -> we can regain data by putting more data with same key

read

we can find data given a key ->
1. in the memtable -> likely the most recent one 
2. in the disk -> we need to look in all the files and retain the one with the highest timestamps -> reliable way to estimate the last timestamp for a specific key

file format 
	one after the other in blocks -> each one a set of data -> several row keys with values -> instead of llokking for the key we can exclude blocks by looking first and last element but we still need to get the page in memory so we add an index that stores the 1st and last element 

index at the beginning or end of a file , end more convenient we can write the index while writing the data blocks -> since it uses many pages -> if its the last one we can store only the blocks that stay in page so we take a trailer at the end as a block that contains metadata about the size and where the index start 

each data block -> seq of key-val pair sorted by key 

key = composed key -> rowkey-columnfamily-columname-timestamp-type-value

type -> what we are doing to key-valu



searching 
