how to restore data 

blocks of rdbms 
split between data model and storage engine

relational engine -> 

storage engine > how we store data 
persistante memory manager -> virtualization of the storage -> we can access data through linear address 

most of teh choiches made when db stored in magnetic disk latency = moving the disk and head in the correct position than we tranfer as fast a the disk rotates etcc

we can put a baffer to store a single page of the disk

we can store data in a file , knowinfÃ¬g that the cost of accesing a bit in the file is the cost of the latency in order to access a page on the disk

a record -> perfect for key value store a prefix and field

all the element on a row in mongodb

record stored in a page and we need a way to refer to position inside a page 

file structures : serial -> append data at the end of a file -> we don't know where things are based on the content -> where is the record of the jungher person > make data permanent but we can't access it efficently 

sequential data ordered by specific field -> update cost is heavy

storing by row we can't easily access data on a column, 1 file for each column if i need to update a whole person i need to recombine the files for each column 

row store -> 1 record after another 
why column store much more evident in nosql dbs 

in datawherhauses could be beneficial 

column store -> the data is written by column , in most cases stored separatly

advantages we can get only relevant data to a current query + since all values on the same column same domain -> easier to compress them since they are similar, computing velues over a column we can just access a single column not an advantage if we need all the column

new colum simply new file 

insering row = change all colum stores 

column compression

we are intrested in *lossless* compression 

1 - run lenght encoding -> exploit presence of repetition in order to have more compact -> shorter rappresentation -> repetitions but not consecutivies -> Claudio = C , another une C+1, or difference between

value + start + lenght -> so that we can reconstruct from any point and start reconstracting from that point 

2 bit vector
or we can store the presence of that value if we have only a small amount of different values 
easly compute bitways operations

3 dictionary encoding 
replace whole values with something that can be stored more efficently ex 1 for 204 we also need to store the dictionary

some queries dont need the dictionary number fo unique el 

if the dictionary doesn't compleatly fit in memory things maybe different in term of efficency 

we could also store the dictionary encoding for sequences 

frame of reference encoding we can have a refernce and store the difference -> use a middle date to rapresent the other dates 

if we have some dates outside a range we can have exception 

consistent number of exception when we move forward in dates 

differential encoding -> store the first value and than difference in respect to the previous value 

if we have dates thata change too much we can compleatly reset the encoding and restart 

more unsurprising is data easier to compress it 

queries on compressed data 

data with lots of empty values -> null suppression > storing theyr position or bitmap the position or a range 

colum store for documents -> docs as a tree the path to the leav is the column name that is assocaite with the value on that path 

mariadb supports sql
apache parquet only how we store data

wiredtiger -> storage engine both row and col access as tables -> in mongodb

extensible columns data model -> colum family store -> groups of columns stored togetere and accessed togheter 

2 componontes : model , how we interact with data 

big table google -> columns often accessed togheter we create a family and access them togheter 

we store column name to store actual data no advantage in model point of view but in the store infrastructure if we are able to access data by column name example all the book landing that elapse on a given date 

based on theyr qualifier -> column family -> lending info than row identifier and than the column qualier and finally the value

each column family stored togheter spacial locality 

data is identified by a code rowkey.columnfamily.columnqualifier
\+ some time data -> timestamp for example 

we can have different version of a value

small amount of updates -> ingestion of new records , distributed 
not frequent update -> record just the fact that data changes starting from now that data has cahnged to that 

