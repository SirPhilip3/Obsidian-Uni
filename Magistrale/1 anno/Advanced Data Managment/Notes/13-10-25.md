mongo db 

document db 

designed for a distributed deployment + high performance 
document can be trasformed in various data model -> document similar to a tree 

mongodb -> query -> find something similar to what i'm loking four -> giving a partial document -> query by example 

base propieties -> 
+ basically available 
+ soft state 
+ eventually consistent -> after an update at some point it will be known to everyone makes sense in a distributed setting -> noone needs to wait for the write to be final -> depends on use case -> ex for reservation not good -> real consistency / bank account -> if it's managing socials we don't care 

use cases -> 
there is no join
no transaction
- everything on a document

example : 
we want to store location + user generated comments 
we want to find nearby location
record checkin
generate stats about check in -> if we wont stast for users and locations -> another collectios

```json
location1 = {
	name : "name1",
	address : "via gioia 12",
	city : "Roma",
	zip : "34112",
	
	tags : ["bussines","villa"],
	latlog : [42.0, 72.2],
	
	tips : [
		{user:"josh", time: 07/23/23, tip : "test ts  s "}
	]
}
```

```
db.location.find({zip: "34112", tags : "villa"})
```

mongodb not suitable for gis data but can calculate disance with euclidian distance if we suppose the are on a plane or in a sphere > distance in a sphere

we need to know the shape of  ... -> approximated to elipsoid -> coords approx of 2 meters

for mongo -> partial schema -> with indexes , makes more efficient searching for something :
```
db.locations.ensureIndex({latlong : "2d"})
```

different kind of indexes , 2d = 2d index -> we can use spatial operator 

```
db.locations.find({latlong : {$near : [40,70]}})
```

tips -> list of documents

insert
```
db.locations.insert(place1)
```

update
```
db.locations.update({name : "10"}, {$push:{tip : {...}}})
```

checkin 

```json
user1 = {
	name: "opopas" ,
	
	checkins : ["name1","name2"]
}
```

or we can use objectid and manage the checkins seperatly -> propieties only to the checkin collection fine otherwise it get's complicated we need to specify how to aggregate data 
like this we can have an index with the checkins of a determined user

almost mundatory to think of the data with clear idea on the operations you want to perform

`.sort({ts:-1}).limit(10)`

---

aggregation pipeline / map reduce

more complex stats -> aggregation -> we need to write the execution plan of an aggregation
