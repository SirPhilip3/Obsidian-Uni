opencypher 

mandatory match -> like assertion -> mandatory -> if not found the fail will report exactly what's missing 

2 parts -> 
+ match 
+ update
(1st graph)
```cypher
MATCH (a : User{name:"Adam"}) -[:Friend]-(u1 : User) -[:Friend]-(u2 : User)
Return u2
```

Friend of a friend of adam -> would be david but u1 has as frind adam and david

every relashionship just once -> we already used the first link (adam) the only remaining will be david 

which are the ffriend of a friend we are no interested in the starting point , if we are interested in the starting point exlpixit by separating the two matches 

```cypher
MATCH (a : User{name:"Adam"}) -[:Friend]-(u1 : User)
MATCH (u1)-[:Friend]-(u2 : User)
Return u2
```

we have 2 results david and adam bc u1 in the second mach has adam and david as friends 

```
(a)
(a)-[]-(b) we can not have a name for the relationship 
(a)-[]-()-[]-(b) any pair of nodes and b connected by rel - any node - rel b

(a:Label)-[]-()
```

propieties `(a:Label{prop1:value})` 

relationships 
```
-[]-
-[r]-
-[r:type]- or -[:type]-
-[:type1 | type2]- valid as query but not to create a relation
```

variable lenght pattern 
```
(a:user)-[*]-(b:user) * for any repetation of any in the middle we can also add a type 
```

we can put contraint on the number of repetition `[*2]`
`[*2..]` at least 2 , 2..5 from 2 to 5 , \*..5 up to 5 

example (2nd graph) 
```cypher
MATCH (m1)-[KNOWS*1..2]-(remote_friend) // reachable by no more than 2 jumps 
WHERE m1.name = 'filipa' // equivalent to (m1:{name='filipa'})
RETURN remote_friend.name
```

filipa not given back in the result due to uniqueness 

3rd graph 
```cypher
MATCH (m : Movies) return m 
MATCH (director : {name : 'oliver stone'}) - [] - (movie) return movie.title // the movie directed by oliver stone 
// if there was some links like worked than movie would have been a person 
// also we didnt give a type of direcor so if there was a movie with title oliver stone than it would select also that 

// improuvments
MATCH (director :Person{name : 'oliver stone'}) - [] - (movie : Movie) return movie.title 

MATCH (director : Person) - [] - (movie) return director.name , movie.title 

```
we can't return full nodes 

direction

we can match a variable to a relationship 
```cypher
MATCH (d : Person{name=''}) - [r] -(movie)
return m.title , type(r) , d.name
// [r:DIRECTED] -> allowed relationship type DIRECTED
```

neo4j escaping character -> backhypher

all persons related to wall street film : 
```cypher
MATCH 
```