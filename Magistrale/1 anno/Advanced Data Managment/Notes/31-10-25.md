opencypher 

mandatory match -> like assertion -> mandatory -> if not found the fail will report exactly what's missing 

2 parts -> 
+ match 
+ update
(1st graph)
```cypher
MATCH (a : User{name:"Adam"}) -[:Friend]-(u1 : User) -[:Friend]-(u2 : User)
Return u2
```

Friend of a friend of adam -> would be david but u1 has as frind adam and david

every relashionship just once -> we already used the first link (adam) the only remaining will be david 

which are the ffriend of a friend we are no interested in the starting point , if we are interested in the starting point exlpixit by separating the two matches 

```cypher
MATCH (a : User{name:"Adam"}) -[:Friend]-(u1 : User)
MATCH (u1)-[:Friend]-(u2 : User)
Return u2
```

we have 2 results david and adam bc u1 in the second mach has adam and david as friends 

```
(a)
(a)-[]-(b) we can not have a name for the relationship 
(a)-[]-()-[]-(b) any pair of nodes and b connected by rel - any node - rel b

(a:Label)-[]-()
```

propieties `(a:Label{prop1:value})` 

relationships 
```
-[]-
-[r]-
-[r:type]- or -[:type]-
-[:type1 | type2]- valid as query but not to create a relation
```

variable lenght pattern 
```
(a:user)-[*]-(b:user) * for any repetation of any in the middle we can also add a type 
```

we can put contraint on the number of repetition `[*2]`
`[*2..]` at least 2 , 2..5 from 2 to 5 , \*..5 up to 5 

example (2nd graph) 
```cypher
MATCH (m1)-[KNOWS*1..2]-(remote_friend) // reachable by no more than 2 jumps 
WHERE m1.name = 'filipa' // equivalent to (m1:{name='filipa'})
RETURN remote_friend.name
```

filipa not given back in the result due to uniqueness 

3rd graph 
```cypher
MATCH (m : Movies) return m 
MATCH (director : {name : 'oliver stone'}) - [] - (movie) return movie.title // the movie directed by oliver stone 
// if there was some links like worked than movie would have been a person 
// also we didnt give a type of direcor so if there was a movie with title oliver stone than it would select also that 

// improuvments
MATCH (director :Person{name : 'oliver stone'}) - [] - (movie : Movie) return movie.title 

MATCH (director : Person) - [] - (movie) return director.name , movie.title 

```
we can't return full nodes 

direction

we can match a variable to a relationship 
```cypher
MATCH (d : Person{name=''}) - [r] -(movie)
return m.title , type(r) , d.name
// [r:DIRECTED] -> allowed relationship type DIRECTED
```

neo4j escaping character -> backhypher

all persons related to wall street film : 
```cypher
MATCH (ws : Movie{title : 'Wall Street'}) - [r:ACTED_IN|DIRECTED] - (p : Person)
Return p.name, type(r)
// limit matching on rel
```

first one acted in second directed 
```cypher
MATCH (a:Person{name='...'}) - [:ACTED_IN] - () - [:DIRECTED] - (d)
// all the movie where martin sheen has actend 
return a.name , m.title , d.name
```

actors that acted togheter in the same movie 
```cypher
MATCH (a1:Person{name='...'}) - [:ACTED_IN] - (m) - [:ACTED_IN] - (a2:Person) 
return a1.name , m.title , a2.name
```

If we are interested only in actor that acted togheder no for the movie 
```cypher
MATCH (a1:Person{name='...'}) - [:ACTED_IN*2]- (a2:Person) 
```

each node has an id also same for relation
```cypher
MATCH (a) - [r] -(b)
WHERE id(a) = 99 | id(r) = 32
RETURN a,b
```

if we return a,b -> we will find a,b and b,a 

some relationship that has some attributes that i dont want to mach 
```cypher
MATCH Path = (charlie : Person) - [r{blocked=false}] - (martin : Person)
RETURN Path 
```

functions :

shortest_path (node1 - \[\*..10\] - node2) input a pattern we can insert some maximum lenght or other , if more than one only the first one mentioned 
all_shortest_paths ()

```cypher
MATCH (m1...),(m2...), p=shortest_path(m1-[*..10]-m2)
RETURN p
```

only that thing that is compleatly mentioned in the pattern is returned 

optional match like left / right join in sql

```cypher
OPTIONAL MATCH (m:Movie{title='wall'}) -[]->()
```

only in opencipher

```cypher
MANDATORY MATCH (p:Person{name='stallone'})
MANDATORY MATCH (p)-[:ACTED_IN]-(m)
RETURN m 
```

when doesnt find anything stallone not find in the db or not acted in any movie

separately we can check this 

mandatory works as assertion if it fails the whole query fails saying which part of the pattern fails 

aggregation in the last part of the satement on the return 
`m.name COUNT` -> the group by is implicit on m.name