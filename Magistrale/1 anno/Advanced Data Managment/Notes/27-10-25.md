neo4j -> cypher query language 

in general goal of a query to find path or stats about the path

Cypher -> patter matching query language

like regexp -> `C(.*)ab$` several possibilities : `CCCab` -> depending on where we start we can have different results 

its declaratieve -> we specify which pattern we are interested in 
`:` to mark types 

`(:Person{name:"Dan"}) - [:LOVES] -> (:Person{name:"Ann"})`

Add CREATE to add new nodes and patterns 

`CREATE(:Person{name:"Dan"}) - [:LOVES] -> (:Person{name:"Ann"})`

variable -> to return what we are interestes -> every possible path from dan to someone else with rel loves -> the return is not necessary a person

`MATCH(:Person{name:"Dan"}) - [:LOVES] -> (whom) RETURN whom`

we can add contraints like what types of node we want returned 

we can return a subgraph

() -> node
--> / -[]-> relationship

return -> we can return any variables that we specified in the pattern 
```cypher
MATCH (m:Movie)
RETURN m

MATCH (p:Person)-[r:ACTED_IN]->(m:Movie)
RETURN p, r, m

MATCH path = (:Person)-[:ACTED_IN]->(:Movie)
RETURN path

MATCH (m:Movie)
RETURN m.title, m.released
```

Contraints and indexes

Unique -> automatic index creation in postgres -> we need intex in order to check in a fast way the uniqueness

```cypher
CREATE CONSTRAINT ON (label:Label)
ASSERT label.property IS UNIQUE

CREATE CONSTRAINT ON (label:Label)
ASSERT EXISTS(label.name) // everyone needs to have a name

CREATE CONSTRAINT ON ()-[rel:REL_TYPE]->()
ASSERT EXISTS(rel.name) // existance of a relationship with type REL_TYPE
```

indexes 

used to find starting point of query 

updating content of a node 
```cypher
MATCH (m:Movie {title: 'Mystic River'})
SET m.tagline = 'We bury our sins here, Dave. We wash them
clean.'
RETURN m
```

creating a relationship create adds everyinth that is described inside a statement , we need to find the 2 nodes and create the relashionship

first we need to match the 2 nodes and  than connect them 
```cypher
MATCH (m:Movie {title: 'Mystic River'})
MATCH (p:Person {name: 'Kevin Bacon'})
CREATE (p)-[r:ACTED_IN {roles: ['Sean']}]->(m)
RETURN p, r, m
```

if we put inside () in create the match clouse it will create the nodes not match it 

merge -> if it exists we set the other things otherwise it creates it > if it exists it updates 

on create / on match -> executes something depending if match or create has been issued

we can do csv import / export

if the same actor acted twice in the same movie with different roles -> we would need  to have 2 relashionship with the same type to the same movie -> this can't be done in graph model