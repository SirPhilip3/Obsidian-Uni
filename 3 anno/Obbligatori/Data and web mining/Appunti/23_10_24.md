---
creation: 2024-10-23T11:50:00
tags:
  - appunti
---
**PKI**

distribuire chiavi pubbliche -> tramite ascii file + metadata

generare una fingerprint -> hash della key distribuita , servono dei server da dove prendere la key data hash

key server -> usa protocollo per mettere la tua key e cercare , server la propagano a altri server

$n$ deve essere sempre differente 

gpg -> usa input come seed per il generatore di numeri pseudocasuali , prende un numero casuale (basato su seed di prima) grande e vede se è primo , ne troviamo 2 e li usa per p e q

normalmente crea key di 3072bit , ha una data di scadenza , revoca automatica della key

SC -> signature cert usata sola per firme digitali  , E -> encr solo per encryption 
gpg le usa in modo differente , E è sottokey di SC che è stata firmata con SC

se perdi E posso comunque generarne una nuova con SC 

SC posso revocare le altre key cambiandone il metadato di scadenza

**Web of Trust** , rete di deleghe di fiducia --

un terzo B e A si fidano -> A e B usano carl per certificare la loro identità in modo che A e B possono prendere le public key

Carl firma con la sua private key che la key pubblica di Alice è relamente di Alice , tutti possono verficarlo con la sua public key

Si assume che carl sia fidato 

**Carl** diventa un single point of failure, introduciamo gerarchia di certificatori 

^
 |

Sufficente che noi sappiamo che la pagina che visitiamo è realmente quello ma alla pagina non interessa chi siamo noi 

**Public Key Infrastructure**

server e servizi per certificare key e generare certificati , certification authoirty , tutti si fidano e server per certificare la key degli altri

certificate signing request , chiave pubblica di Alice + id di alice + frima di queste  due , x.509 

certificato -> CSR firmato da cert auth
CA non serve quando ci scambiamo info -> non dobbiamo mai mostrare la mia private key

cifrare cose con private key è oneroso ,si fa hash del certificato e si firma sull'hash

se bob vuole navigare in sito di alice , prende il certificato e vede che sia valido per quel dominio , controlla che CA sia consciuta a lui , deve avere pub key, decifra con la pub key della CA , fa digest e controlla che lhash sia uguale 

Eudoroam -> challenge simile a CRAM-MD5 + certificato 

facile da fare offline bruteforce solo cram-md5

CA idealmente ce ne sono troppe , non vorrei mettere nel broswer un public key di una CA di cui non mi fido , gerarchia di CA

*root CA* -> 