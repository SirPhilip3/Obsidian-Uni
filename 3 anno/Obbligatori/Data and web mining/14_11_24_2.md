---
creation: 2024-12-02T12:11:00
publish: true
---
## Computational complexity

Possiamo seguire tre strategie per scrivere l'*algoritmo* di 
### Naive Implementation

Questa avrà come complessità computazionale $O(n^3)$

Inizialmente dovremo computare tutta la tabella delle similarità : $O(n^2)$
Ogni step dell'algoritmo richiede : 
+ Trovare il minimo tra $n^2$ elementi , questo ha complessità $O(n^2)$
+ Compurare la distanza tra il nuovo cluster e gli altri $n$ cluster / punti $O(n)$  
+ Aggiornare $n$ entries nella *similarity matrix* $O(n)$

Visto che al massimo l'algoritmo può fare $n$ passi avremo che la complessità sarà : 
$$n^2+ n \cdot (n^2+n+n) = O(n^3)$$
### Min-Heap based

Questa avrà come complessità computazionale $O(n^2 \cdot \log n)$ 

Computa le $n^2$ similarità ( $O(n^2)$ ) 
Per ogni riga manteniamo un *min-heap* che mantiene le distanze verso gli altri $n$ punti $O(n\cdot n \log n)$
Ogni step dell'algoritmo richiede : 
+ Trovare il minimo tra i *min-heap* e rimuoverlo $O(n + \log n)$
+ Computare la distanza tra il nuovo cluster e gli altri $n$ *cluster* / *punti* $O(n)$
+ Inserire le nuove $n$ similarità nei vari *min-heap* $O(n\log n)$

La complessità totale sarà quindi : 
$$O(n^2) + O(n\cdot n \log n) = O(n^2 \log n)$$
### Single Linkage

Questa avrà come complessità computazionale $O(n^2)$

Questo può avvenire poichè 