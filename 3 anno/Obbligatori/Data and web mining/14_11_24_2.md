---
creation: 2024-12-02T12:11:00
publish: true
---
## Computational complexity

Possiamo seguire tre strategie per scrivere l'*algoritmo* di 
### Naive Implementation

Questa avrà come complessità computazionale $O(n^3)$

Inizialmente dovremo computare tutta la tabella delle similarità : $O(n^2)$
Ogni step dell'algoritmo richiede : 
+ Trovare il minimo tra $n^2$ elementi , questo ha complessità $O(n^2)$
+ Compurare la distanza tra il nuovo cluster e gli altri $n$ cluster / punti $O(n)$  
+ Aggiornare $n$ entries nella *similarity matrix* $O(n)$

Visto che al massimo l'algoritmo può fare $n$ passi avremo che la complessità sarà : 
$$n^2+ n \cdot (n^2+n+n) = O(n^3)$$
### Min-Heap based

Questa avrà come complessità computazionale $O(n^2 \cdot \log n)$ 

Computa le $n^2$ similarità ( $O(n^2)$ ) 
Per ogni riga manteniamo un *min-heap* che mantiene le distanze verso gli altri $n$ punti $O(n\cdot n \log n)$
Ogni step dell'algoritmo richiede : 
+ Trovare il minimo tra i *min-heap* e rimuoverlo $O(n + \log n)$
+ Computare la distanza tra il nuovo cluster e gli altri $n$ *cluster* / *punti* $O(n)$
+ Inserire le nuove $n$ similarità nei vari *min-heap* $O(n\log n)$

La complessità totale sarà quindi : 
$$O(n^2) + O(n\cdot n \log n) = O(n^2 \log n)$$
### Single Linkage

Questa avrà come complessità computazionale $O(n^2)$
>[!note] 
Questo può avvenire poichè un nuovo *cluster* non può avvicinarsi rispetto ad uno più vecchio 

Computa le $n^2$ similarità $O(n^2)$
+ Per ogni *cluster* manteniamo solo il suo più vicino e la sua distanza in una lista di coppie $V(distance,id)$ di dimensione $n$ 
Ogni step dell'algortimo richiede : 
+ Trovare la distanza minima all'interno di $V$ : $O(n)$
+ Computare la matrice delle distanze tra il nuovo cluster e gli altri $n$ cluster / punti $O(n)$
+ Aggiornare le similarità contenute in $V$ : $O(n)$

La complessità totale sarà quindi : 
$$O(n^2) + O(n\cdot n ) = O(n^2)$$
>[!example] 
>![[Pasted image 20241202133447.png]]

