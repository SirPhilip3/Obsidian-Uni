---
creation: 2024-11-12T12:14:00
---
**Protocolli**

Protocolli a livello applicazione , sotto c'è livello di trasporto -> per multiplexing e reliability , ogni porta = specifica applicazione su quel pc , indirizzo ip -> 

2 livelli di trasporto impl con 2 protocolli
TCP (connessione tcp -> 4 valori e uno stato ) , UDP ( perdiamo termine connessione , non ha uno stato , usa solo checkus ) 

indirizzo IP, ogni scheda di rete un indirizzo di rete 

due tipi di IP 
IPv4 -> otetto per ottetto separato da .32 bit
ipv6 -> quattro bit per volta 128 bit

nomi per gli indirizzi ip 

**DNS** -> trasforma nome a ip 

Domain name -> stringa separata da punti , i punti separano le componenti , introducono una gerarchia a dx -> TLD .it etcc 

icann gestisce i domini , altre org gestiscono i TLD a loro volta possono delegare sottodomini

come il broswer risolve example.com -> esistono 13 root dns server , mantengono associazioni tra i server dns che gestiscono i TLD , i broswer li hanno già salvati , il broswer chiede al rootserver l'ip di example.com , gli dice l'ip del .com e poi chiede a .com chi è example.com , gli ritorna quello che gestisce example.com e ritorna l'ip

inefficente , normalmente cerchiamo di evitare tutti i passaggi , ossia ogni rete che offre un indirizzo ha una sua infrastruttura e dentro ha un dns che fa questo per tutti i terminali dentro la rete 

le domande vengono fatta al server locale che fa le domande a tutti gli altri DNS e poi da solo la risposta finale 

query ricorsive -> quando delego un server locale di fare query iterative verso l'esterno , il dns locale accetta query ricorsive solo da quelli dentro rete locale 

il server DNS locale diventa una cache , se richiedo indirizzi già chiesti me lo da direttamente , se chiedo indirizzi vicini -> il server dns local ha anche tutti i server DNS middleman per quell'address

**DNS protocol** 

dobbiamo mantenere un minimo stato se facciamo multiple domande nel client ma non serve nel server , ha bisogno reliability comunque , abbiamo bisogno di sicurezza 

inizialmente DNS non ha sicurezza ora utilizziamo DNSsec o DNS su TCP 

**formato originale di DNS** : 
+ header
+ question
+ answer : contengono resource record
+ authority : contengono resource record
+ addizionali

header all'inizio un id casuale che deve essere matchato nella risposta
QR : query type
AA : se è authoritative
RD : se la richiesta è recursive o iterative 
RA: se il server supporta recursive

resource record .... 

+ Name: The name that was requested (both in
the query and in the replies).
+ Type:
	+ A: IPv4 host address
	+ AAAA: IPv6 host address
	+ NS: Authoritative Name Server
	+ MX: Mail Exchange
	+ CNAME: Alias for the same resource
	+ SOA: Generic data on the owner (e-mail, expiration. . . )
	+ TXT: Anything
+ TTL: The time this information can be cached, before it must be queried again
+ RDLENGTH: The length of the RDATA field
+ RDATA: The actual information

Possiamo fare risoluzione da indirizzo ip a dominio , risoluzione ptr , ha il suo tipo nel DNS 

nella pratica se vogliamo fare il reverse dobbiamo fare un ricreca dns dell'indirizzo ip al contrario prima chiedendo a in-addr.arpa -> chiede a dns che gestisce il top level ip address e così via
`1.2.3.5 -> 5.3.2.1.in-addr.arpa` 

non siamo obbligati a registrare il dominio inverso , utile per gestire posta elettronica 

