---
creation: 2024-09-30T15:46:00
tags:
  - appunti
---
```js
let v1 = {x:0, y:1,len:function(){...}}
```

```js
let v2 = {x = 7,y = 7, v1.len} // copio il pointer alla stessa funzione 
let l1 = v2.len()
```

la funzione in una classe non sta in memoria ma sta in class model , a runtime cerca vector.class , carica la funzione in una memoria di "classe"

visto che v1 non è più importante di v2 possiamo : 
```js
let vlen = function(){return Math.sqrt(this.x*this.x+this.y*this.y),}
let v1 = {x:0,y:1,len:vlen}
let v2 = {x:2, y:3,len:vlen}
let l1 = v2.len() // execute la function
```

vlen sta in global e copio il suo address nelle "classi" , prende natura di metodo quando la invoco con ()

migliore dei casi sarà undefined , nel peggiore dei casi trova una variabile globale x e da errore silente

```js
let vlen = function(){return Math.sqrt(this.x*this.x+this.y*this.y)}
let v2 = {x:"dsfds", t:"hete", len:vlen} // silent error (NaN)
let l1 = v2.len() // execute la function
console.log(l1) 
```
 
L'unico modo per "definire" ogg -> unico modo attraverso i campi che si aspetta il metodo 

finchè l'oggetto contiene ciò che il metodo vuole funzionerà ( ducktyping )
```js
let vlen = function(){return Math.sqrt(this.x*this.x+this.y*this.y)}
let v2 = {p:"dsfsd", t:"dsf", x:3, y:32, len:vlen}
let l1 = v2.len() // execute la function prendendo x e y e non p e t
console.log(l1) 
```



template che si comporti come una **classe**

voglio una garanzia minima : 
**prototype**
è un oggetto che ha i requisiti minimi per oggetti dello stesso tipo


```js

```